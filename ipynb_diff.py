#!/bin/python

from argparse import ArgumentParser
from contextlib import contextmanager
from datetime import datetime
from distutils import dir_util
from os import (chdir, getcwd)
from os import path as ospath
from subprocess import check_output

ANSI_LIGHT_RED = 31
ANSI_LIGHT_GREEN = 32


def color(msg, ansicode):
  return '\033[1;{ansicode};40m{msg}\033[0m'.format(msg=msg, ansicode=ansicode)


def echo(subject, ansicode, msg):
  print('{}: {}'.format(color(subject, ansicode), msg))


def cd_echo(path):
  echo('cd', ANSI_LIGHT_GREEN, path)
  chdir(path)


@contextmanager
def cd_if_necessary(path):
  orig = getcwd()
  should_cd = (orig != path)
  try:
    if should_cd:
      cd_echo(path)
    yield
  finally:
    if should_cd:
      cd_echo(orig)
    else:
      pass


class Command(object):

  @staticmethod
  def _echo(args):
    echo("running", ANSI_LIGHT_RED, " ".join(args))

  @classmethod
  def run(cls, args, echo=True):
    if echo:
      cls._echo(args)
    return check_output(args)


@contextmanager
def cd_repo_root():
  args = ['git', 'rev-parse', '--show-toplevel']
  repo_root = Command().run(args).strip('\n')
  try:
    with cd_if_necessary(repo_root):
      yield repo_root
  finally:
    pass


def get_abspath_dict(paths):
  path_dict = {}
  for path in paths:
    basename = path.replace(ospath.sep, "_")
    path_dict[basename] = ospath.abspath(path)
  return path_dict


class Converter(object):
  MESSAGE = (
    'The files in {output_dir}/ were automatically generated by '
    '{program}. These files should not be edited manually.\n\n'
    'Time created: {time}\nCreated from: {paths}\n')

  def __init__(self, path_dict, output_dir, repo_root):
    self.cmd = Command()
    self.repo_root = repo_root
    # make all paths relative to root of the git repo
    self.output_dir = ospath.relpath(output_dir, start=repo_root)
    self.path_dict = self._convert_to_relpaths(path_dict, repo_root)

  @staticmethod
  def _convert_to_relpaths(abspath_dict, root_dir):
    relpath_dict = {}
    for (key, path) in abspath_dict.items():
      relpath_dict[key] = ospath.relpath(path, start=root_dir)
    return relpath_dict

  def _setup(self, start_time):
    dir_util.mkpath(self.output_dir)

    content = self.MESSAGE.format(
      output_dir=self.output_dir,
      program=ospath.basename(__file__),
      paths=self.path_dict,
      time=start_time)

    with open(ospath.join(self.output_dir, 'readme.txt'), 'w') as f:
      f.write(content)

  def _nbconvert(self, path, basename, export_fmt):
    cmd = ['jupyter', 'nbconvert', path,
      '--output={}'.format(basename),
      '--output-dir={}'.format(self.output_dir),
      '--to={}'.format(export_fmt)]

    return self.cmd.run(cmd)

  def _nbconvert_list(self, export_fmt):
    for (basename, path) in self.path_dict.items():
      self._nbconvert(path, basename, export_fmt)

  def to_python(self):
    self._nbconvert_list('python')

  def to_rst(self):
    self._nbconvert_list('rst')

  def convert(self):
    self._setup(datetime.now())
    self.to_python()
    self.to_rst()


def main():
  parser = ArgumentParser()
  parser.add_argument('files', nargs='+')
  parser.add_argument('--output_dir', default='ipynb_generated')
  args = parser.parse_args()

  # convert input paths to absolute paths
  path_dict = get_abspath_dict(args.files)
  output_dir = ospath.abspath(args.output_dir)

  # cd to the root of the git repo and convert files
  with cd_repo_root() as repo_root:
    Converter(path_dict, output_dir, repo_root).convert()

if __name__ == '__main__':
  main()
