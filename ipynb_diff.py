#!/bin/python

from argparse import ArgumentParser
from contextlib import contextmanager
from datetime import datetime
from distutils import dir_util
import json
import logging
from os import (chdir, getcwd)
from os import path as ospath
from subprocess import (CalledProcessError, check_output)

ANSI_LIGHT_RED = 31
ANSI_LIGHT_GREEN = 32

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)


def _log_setup(log_dir):
  # log setup
  formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

  # output to file
  log_file = '{}.log'.format(ospath.basename(__file__))
  fh = logging.FileHandler(ospath.join(log_dir, log_file))
  fh.setLevel(logging.DEBUG)
  fh.setFormatter(formatter)
  logger.addHandler(fh)

  # output to console
  ch = logging.StreamHandler()
  ch.setLevel(logging.INFO)
  ch.setFormatter(formatter)
  logger.addHandler(ch)


def color(msg, ansicode):
  return '\033[1;{ansicode};40m{msg}\033[0m'.format(msg=msg, ansicode=ansicode)


def echo(subject, ansicode, msg):
  logger.info('{}: {}'.format(color(subject, ansicode), msg))


def cd_echo(path):
  echo('cd', ANSI_LIGHT_GREEN, path)
  chdir(path)


@contextmanager
def cd_if_necessary(path):
  orig = getcwd()
  should_cd = (orig != path)
  try:
    if should_cd:
      cd_echo(path)
    yield
  finally:
    if should_cd:
      cd_echo(orig)
    else:
      pass


class Command(object):

  @staticmethod
  def _echo(args):
    echo("running", ANSI_LIGHT_RED, " ".join(args))

  @classmethod
  def run(cls, args, echo=True):
    if echo:
      cls._echo(args)
    return check_output(args)


@contextmanager
def cd_repo_root():
  args = ['git', 'rev-parse', '--show-toplevel']
  repo_root = Command().run(args).strip('\n')
  try:
    with cd_if_necessary(repo_root):
      yield repo_root
  finally:
    pass


def get_abspath_dict(paths):
  path_dict = {}
  for path in paths:
    basename = path.replace(ospath.sep, "_")
    path_dict[basename] = ospath.abspath(path)
  return path_dict


class Converter(object):
  README_MESSAGE = (
    'The files in {output_dir}/ were automatically generated by '
    '{program}. Do not edit manually.\n')

  class JupyterCommandMissing(Exception):
    pass

  class JupyterCommandFailure(Exception):
    pass

  def __init__(self, path_dict, output_dir, repo_root):
    self.cmd = Command()
    self.repo_root = repo_root
    # make all paths relative to root of the git repo
    self.output_dir = ospath.relpath(output_dir, start=repo_root)
    self.path_dict = self._convert_to_relpaths(path_dict, repo_root)

  @staticmethod
  def _convert_to_relpaths(abspath_dict, root_dir):
    relpath_dict = {}
    for (key, path) in abspath_dict.items():
      relpath_dict[key] = ospath.relpath(path, start=root_dir)
    return relpath_dict

  def _write_file(self, path, content):
    with open(ospath.join(self.output_dir, path), 'w') as f:
      f.write(content)

  def _write_data(self):
    data = dict(
      program=ospath.basename(__file__),
      output_dir=self.output_dir,
      time_created=str(datetime.now()),
      files_converted=self.path_dict)

    content = json.dumps(data, indent=2, sort_keys=True)
    self._write_file('data.json', content)

  def _write_readme(self):
    content = self.README_MESSAGE.format(
      output_dir=self.output_dir,
      program=ospath.basename(__file__))

    self._write_file('readme.txt', content)

  def _setup(self):
    dir_util.mkpath(self.output_dir)
    self._write_data()
    self._write_readme()


  def _nbconvert(self, path, basename, export_fmt):
    cmd = ['jupyter', 'nbconvert', path,
      '--output={}'.format(basename),
      '--output-dir={}'.format(self.output_dir),
      '--to={}'.format(export_fmt)]

    try:
      return self.cmd.run(cmd)
    except OSError:
      msg = ("The jupyter command was not found on your machine. "
        "Please install all requirements in requirements.txt first.")
      logging.exception("message")
      raise self.JupyterCommandMissing(msg)
    except CalledProcessError:
      logging.exception("message")
      raise self.JupyterCommandFailure("The jupyter command failed.")

  def _nbconvert_list(self, export_fmt):
    for (basename, path) in self.path_dict.items():
      logger.debug('Converting {} to {}'.format(path, export_fmt))
      self._nbconvert(path, basename, export_fmt)

  def _to_python(self):
    self._nbconvert_list('python')

  def _to_rst(self):
    self._nbconvert_list('rst')

  def _teardown(self):
    msg = "generated content for {} ipynb file(s) in {}/".format(
      len(self.path_dict), self.output_dir)
    echo("finished", ANSI_LIGHT_GREEN, msg)

  def convert(self):
    self._setup()
    self._to_python()
    self._to_rst()
    self._teardown()


def main():
  parser = ArgumentParser()
  parser.add_argument('files', nargs='+')
  parser.add_argument('--output_dir', default='ipynb_generated')
  args = parser.parse_args()

  # convert input paths to absolute paths
  path_dict = get_abspath_dict(args.files)
  output_dir = ospath.abspath(args.output_dir)

  _log_setup(output_dir)

  # cd to the root of the git repo and convert files
  with cd_repo_root() as repo_root:
    Converter(path_dict, output_dir, repo_root).convert()

if __name__ == '__main__':
  main()
