from datetime import datetime
from distutils import dir_util
import json
import logging
from os import path as ospath
from subprocess import CalledProcessError

from .command import (ANSI_LIGHT_GREEN, Command, echo)

logger = logging.getLogger()


class Converter(object):
  README_MESSAGE = (
    'The files in {output_dir}/ were automatically generated by '
    '{program}. Do not edit manually.\n')

  class JupyterCommandMissing(Exception):
    pass

  class JupyterCommandFailure(Exception):
    pass

  def __init__(self, path_dict, output_dir, repo_root):
    self.cmd = Command()
    self.repo_root = repo_root
    # make all paths relative to root of the git repo
    self.output_dir = ospath.relpath(output_dir, start=repo_root)
    self.path_dict = self._convert_to_relpaths(path_dict, repo_root)

  @staticmethod
  def _convert_to_relpaths(abspath_dict, root_dir):
    relpath_dict = {}
    for (key, path) in abspath_dict.items():
      relpath_dict[key] = ospath.relpath(path, start=root_dir)
    return relpath_dict

  def _write_file(self, path, content):
    abspath = ospath.abspath(ospath.join(self.output_dir, path))
    with open(abspath, 'w') as f:
      f.write(content)
    nbytes = ospath.getsize(abspath)
    logger.debug("wrote {} bytes to {}".format(nbytes, abspath))

  def _write_data(self):
    data = dict(
      program=ospath.basename(__file__),
      output_dir=self.output_dir,
      time_created=str(datetime.now()),
      files_converted=self.path_dict)

    content = json.dumps(data, indent=2, sort_keys=True)
    self._write_file('data.json', content)

  def _write_readme(self):
    content = self.README_MESSAGE.format(
      output_dir=self.output_dir,
      program=ospath.basename(__file__))

    self._write_file('readme.txt', content)

  def _write_gitignore(self):
    content = ("*.log\n")
    self._write_file('.gitignore', content)

  def _setup(self):
    dir_util.mkpath(self.output_dir)
    self._write_data()
    self._write_readme()
    self._write_gitignore()


  def _nbconvert(self, path, basename, export_fmt):
    cmd = ['jupyter', 'nbconvert', path,
      '--output={}'.format(basename),
      '--output-dir={}'.format(self.output_dir),
      '--to={}'.format(export_fmt)]

    try:
      return self.cmd.run(cmd)
    except OSError:
      msg = ("The jupyter command was not found on your machine. "
        "Please install all requirements in requirements.txt first.")
      logging.exception("message")
      raise self.JupyterCommandMissing(msg)
    except CalledProcessError:
      logging.exception("message")
      raise self.JupyterCommandFailure("The jupyter command failed.")

  def _nbconvert_list(self, export_fmt):
    for (basename, path) in self.path_dict.items():
      logger.debug('Converting {} to {}'.format(path, export_fmt))
      self._nbconvert(path, basename, export_fmt)

  def _to_python(self):
    self._nbconvert_list('python')

  def _to_rst(self):
    self._nbconvert_list('rst')

  def _teardown(self):
    msg = "generated content for {} ipynb file(s) in {}/".format(
      len(self.path_dict), self.output_dir)
    echo("finished", ANSI_LIGHT_GREEN, msg)

  def convert(self):
    self._setup()
    self._to_python()
    self._to_rst()
    self._teardown()
